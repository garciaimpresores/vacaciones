import { db } from './config';
import {
    collection,
    onSnapshot,
    addDoc,
    updateDoc,
    deleteDoc,
    doc,
    query,
    orderBy
} from 'firebase/firestore';

const COLLECTIONS = {
    EMPLOYEES: 'employees',
    VACATIONS: 'vacations',
    EVENTS: 'events'
};

// --- Employees ---

export const subscribeToEmployees = (callback) => {
    const q = query(collection(db, COLLECTIONS.EMPLOYEES), orderBy('name'));
    return onSnapshot(q, (snapshot) => {
        const data = snapshot.docs.map(doc => ({
            id: doc.id,
            ...doc.data()
        }));
        callback(data);
    });
};

export const addEmployee = async (employee) => {
    const { id, ...data } = employee; // Firestore generates its own IDs usually, but we might want to keep using ours or let Firestore do it.
    // Ideally, let Firestore generate ID. If we use our own UUIDs, we should use setDoc.
    // For simplicity and consistency with existing code, let's just add the doc and let Firestore generate the ID, 
    // OR if the app relies on specific ID formats, we might need to adjust.
    // The existing app generates crypto.randomUUID(). 
    // Let's remove the ID from the data payload and use addDoc (which gives a new ID), 
    // OR we can use setDoc with the existing ID if we want to preserve that logic.
    // However, easier to just use addDoc and let the object have the Firestore ID when retrieved.

    // Actually, to make migration seamless, let's just pass the data. 
    // If the passed employee object already has an ID (generated by frontend), we can check.
    // But usually best practice is let backend generate ID.
    // We will ignore the frontend generated ID and let Firestore assign one.

    // WAIT: The 'id' is used for relationships (incompatibleIds). 
    // If we change the ID generation strategy, we must ensure incompatibleIds still reference valid IDs.
    // It's safer to use `setDoc` with the generated UUID from the frontend if we want to keep frontend generation,
    // OR just switch to Firestore IDs everywhere.

    // Strategy: Let's use the local ID if provided, otherwise let Firestore generate.
    // But `addDoc` auto-generates. `setDoc` needs a ref.
    // We'll use `addDoc` for new items and the app will adapt to use the Firestore ID from the snapshot.

    // But wait, `incompatibleIds` store references to other IDs.
    // If I create Employee A, I don't know their Firestore ID until the promise resolves.
    // Existing code generates ID *before* adding to state.
    // So validation/relationships work immediately.

    // To keep it simple: We will use `addDoc` and update the local state via the subscription.
    // Meaning we don't strictly *need* to know the ID before creation unless we are doing complex batch operations.
    // The frontend currently generates an ID. We will DROP that ID and let Firestore assign a new one.
    // Relationships (incompatibilities) will need to be updated with the new Real IDs.
    // This might be tricky if I link A to B and B doesn't exist yet?
    // No, you link to *existing* employees. So B already has an ID.

    // OK, plan:
    // 1. We strip the local `id` property before saving to Firestore.
    // 2. Firestore assigns a document ID.
    // 3. The `subscribeToEmployees` maps `doc.id` back to the `id` property of the object.
    // This works perfectly.

    try {
        // Ensure we don't save the 'id' field as part of the document data, 
        // to avoid confusion between doc.id and data.id
        const { id, ...cleanData } = employee;
        await addDoc(collection(db, COLLECTIONS.EMPLOYEES), cleanData);
    } catch (error) {
        console.error("Error adding employee: ", error);
        throw error;
    }
};

export const updateEmployee = async (employee) => {
    try {
        const { id, ...data } = employee;
        const docRef = doc(db, COLLECTIONS.EMPLOYEES, id);
        await updateDoc(docRef, data);
    } catch (error) {
        console.error("Error updating employee: ", error);
        throw error;
    }
};

export const deleteEmployee = async (id) => {
    try {
        await deleteDoc(doc(db, COLLECTIONS.EMPLOYEES, id));
    } catch (error) {
        console.error("Error deleting employee: ", error);
        throw error;
    }
};

// --- Vacations ---

export const subscribeToVacations = (callback) => {
    const q = query(collection(db, COLLECTIONS.VACATIONS));
    return onSnapshot(q, (snapshot) => {
        const data = snapshot.docs.map(doc => ({
            id: doc.id,
            ...doc.data()
        }));
        callback(data);
    });
};

export const addVacation = async (vacation) => {
    try {
        const { id, ...cleanData } = vacation;
        await addDoc(collection(db, COLLECTIONS.VACATIONS), cleanData);
    } catch (error) {
        console.error("Error adding vacation: ", error);
        throw error;
    }
};

export const updateVacation = async (vacation) => {
    try {
        const { id, ...data } = vacation;
        const docRef = doc(db, COLLECTIONS.VACATIONS, id);
        await updateDoc(docRef, data);
    } catch (error) {
        console.error("Error updating vacation: ", error);
        throw error;
    }
};

export const deleteVacation = async (id) => {
    try {
        await deleteDoc(doc(db, COLLECTIONS.VACATIONS, id));
    } catch (error) {
        console.error("Error deleting vacation: ", error);
        throw error;
    }
};

// --- Events ---

export const subscribeToEvents = (callback) => {
    const q = query(collection(db, COLLECTIONS.EVENTS));
    return onSnapshot(q, (snapshot) => {
        const data = snapshot.docs.map(doc => ({
            id: doc.id,
            ...doc.data()
        }));
        callback(data);
    });
};

export const addEvent = async (event) => {
    try {
        const { id, ...cleanData } = event;
        await addDoc(collection(db, COLLECTIONS.EVENTS), cleanData);
    } catch (error) {
        console.error("Error adding event: ", error);
        throw error;
    }
};

export const updateEvent = async (event) => {
    try {
        const { id, ...data } = event;
        const docRef = doc(db, COLLECTIONS.EVENTS, id);
        await updateDoc(docRef, data);
    } catch (error) {
        console.error("Error updating event: ", error);
        throw error;
    }
};

export const deleteEvent = async (id) => {
    try {
        await deleteDoc(doc(db, COLLECTIONS.EVENTS, id));
    } catch (error) {
        console.error("Error deleting event: ", error);
        throw error;
    }
};
